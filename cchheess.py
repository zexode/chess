import copy  # Импортируем модуль copy для создания глубоких копий объектов. Это нужно для функции undo, чтобы сохранить неизменные состояния доски.

class Game:  # Определяем базовый класс Game, который будет использоваться как основа для игр (шахматы и шашки).
    def __init__(self):  # Конструктор класса Game, вызывается при создании экземпляра класса.
        self.move_history = []  # Инициализируем пустой список для хранения истории состояний доски после каждого хода.

    def save_state(self):  # Метод для сохранения текущего состояния игровой доски.
        self.move_history.append(copy.deepcopy(self.board))  # Добавляем в список move_history глубокую копию текущей доски (board), чтобы изменения в будущем не повлияли на сохранённые состояния.

    def undo_moves(self, n):  # Метод для отката игры на n ходов назад.
        if n <= len(self.move_history):  # Проверяем, достаточно ли сохранённых ходов в истории для отката на n шагов.
            self.board = self.move_history[-n]  # Устанавливаем текущее состояние доски на то, что было n ходов назад (берем элемент с конца списка).
            self.move_history = self.move_history[:-n]  # Обрезаем список истории, удаляя последние n состояний, так как мы вернулись назад.
            print(f"Вернулись на {n} ход(ов) назад.")  # Выводим сообщение об успешном выполнении отката.
        else:  # Если запрошено больше ходов, чем есть в истории.
            print("Невозможно вернуть столько ходов назад.")  # Выводим сообщение о невозможности отката.

    def play(self):  # Абстрактный метод play, который должен быть реализован в классах-наследниках.
        raise NotImplementedError("Метод play() должен быть реализован в наследниках.")  # Вызываем исключение, если метод не переопределён в дочернем классе.


# =============================== ШАХМАТЫ ===============================
class ChessGame(Game):  # Определяем класс ChessGame, который наследуется от базового класса Game для реализации шахмат.
    def __init__(self):  # Конструктор класса ChessGame, вызывается при создании экземпляра шахматной игры.
        super().__init__()  # Вызываем конструктор родительского класса Game для инициализации move_history.
        self.board = self.init_board()  # Инициализируем шахматную доску начальными позициями фигур, вызывая метод init_board.
        self.turn = "white"  # Устанавливаем, что первый ход за белыми (переменная хранит текущего игрока).
        self.en_passant_target = None  # Инициализируем атрибут для хранения клетки, доступной для взятия на проходе (по умолчанию None).
        self.en_passant_pawn = None  # Инициализируем атрибут для хранения координат пешки, которая сделала двойной ход (по умолчанию None).

    def init_board(self):  # Метод для создания и инициализации шахматной доски.
        board = [[None for _ in range(8)] for _ in range(8)]  # Создаём двумерный массив 8x8, заполненный значениями None (пустая доска).
        board[0][0] = Rook("black")
        board[0][1] = Knight("black")
        board[0][2] = Bishop("black")
        board[0][3] = Queen("black")
        board[0][4] = King("black")
        board[0][5] = Bishop("black")
        board[0][6] = Knight("black")
        board[0][7] = Rook("black")
        for j in range(8):  # Цикл для размещения чёрных пешек на второй строке (ряд 1 с индексом 1).
            board[1][j] = Pawn("black")  # Заполняем ряд 1 чёрными пешками (от a7 до h7).
        for j in range(8):  # Цикл для размещения белых пешек на седьмой строке (ряд 6 с индексом 6).
            board[6][j] = Pawn("white")  # Заполняем ряд 6 белыми пешками (от a2 до h2).
        board[7][0] = Rook("white")
        board[7][1] = Knight("white")
        board[7][2] = Bishop("white")
        board[7][3] = Queen("white")
        board[7][4] = King("white")
        board[7][5] = Bishop("white")
        board[7][6] = Knight("white")
        board[7][7] = Rook("white")
        return board  # Возвращаем полностью инициализированную шахматную доску.

    def is_under_threat(self, pos, piece):  # Метод проверяет, находится ли фигура на позиции pos под угрозой (шахом).
        enemy_color = "black" if piece.color == "white" else "white"  # Определяем цвет противника: если фигура белая, враг — чёрный, и наоборот.
        for i in range(8):  # Проходим по всем строкам доски (индексы 0-7).
            for j in range(8):  # Проходим по всем столбцам доски (индексы 0-7).
                p = self.board[i][j]  # Получаем фигуру на текущей клетке (i, j).
                if p and p.color == enemy_color:  # Если на клетке есть фигура и она принадлежит противнику.
                    if pos in p.get_possible_moves((i, j), self.board):  # Проверяем, может ли эта фигура атаковать позицию pos, вызывая её метод get_possible_moves.
                        return True  # Если позиция pos доступна для атаки, возвращаем True (фигура под угрозой).
        return False  # Если ни одна фигура противника не угрожает pos, возвращаем False.

    def display_board(self):  # Метод для отображения текущего состояния шахматной доски в консоли.
        print("  A B C D E F G H")  # Выводим заголовок с обозначениями столбцов (A-H).
        print()  # Печатаем пустую строку для разделения заголовка и доски.
        for i in range(8):  # Проходим по всем строкам доски (индексы 0-7).
            row_label = 8 - i  # Вычисляем номер строки для отображения (нумерация от 8 до 1 сверху вниз).
            row_str = str(row_label)  # Начинаем строку с номера строки (например, "8").
            for j in range(8):  # Проходим по всем столбцам в текущей строке (индексы 0-7).
                piece = self.board[i][j]  # Получаем фигуру на текущей клетке (i, j).
                if piece:  # Если на клетке есть фигура.
                    cell = piece.symbol  # Получаем символ фигуры (например, "P" для пешки).
                    if self.is_under_threat((i, j), piece):  # Проверяем, находится ли фигура под угрозой (шахом).
                        cell += "!"  # Если да, добавляем восклицательный знак к символу (например, "P!").
                else:  # Если клетка пуста.
                    cell = "."  # Используем точку для обозначения пустой клетки.
                row_str += " " + cell  # Добавляем символ клетки к строке с пробелом перед ним для читаемости.
            row_str += " " + str(row_label)  # Добавляем номер строки в конец для симметрии (например, "8 ... 8").
            print(row_str)  # Выводим сформированную строку с содержимым ряда.
        print()  # Печатаем пустую строку после доски для разделения.
        print("  A B C D E F G H")  # Повторно выводим заголовок с обозначениями столбцов (A-H).

    def convert_input_to_coords(self, inp):  # Метод преобразует ввод пользователя (например, "e2") в координаты на доске (row, col).
        col = ord(inp[0].lower()) - ord('a')  # Преобразуем букву (A-H) в индекс столбца (0-7): вычитаем код символа 'a' из кода введённой буквы.
        row = 8 - int(inp[1])  # Преобразуем цифру (1-8) в индекс строки (0-7): вычитаем введённое число из 8, так как нумерация сверху вниз.
        return (row, col)  # Возвращаем кортеж с координатами (строка, столбец).

    def get_possible_moves(self, pos):  # Метод возвращает список возможных ходов для фигуры на позиции pos.
        i, j = pos  # Разделяем кортеж позиции на индексы строки (i) и столбца (j).
        piece = self.board[i][j]  # Получаем фигуру на указанной позиции.
        if piece:  # Если на позиции есть фигура.
            if isinstance(piece, Pawn):  # Проверяем, является ли фигура пешкой.
                return piece.get_possible_moves(pos, self.board, self.en_passant_target)  # Для пешки вызываем её метод get_possible_moves с учётом en_passant_target.
            else:  # Если фигура не пешка.
                return piece.get_possible_moves(pos, self.board)  # Вызываем метод get_possible_moves для других фигур без дополнительных параметров.
        return []  # Если на позиции нет фигуры, возвращаем пустой список.

    def can_castle(self, king):  # Метод проверяет, возможна ли рокировка для указанного короля.
        options = {}  # Создаём пустой словарь для хранения вариантов рокировки.
        if king.has_moved:  # Если король уже ходил.
            return options  # Возвращаем пустой словарь, так как рокировка невозможна.
        row = 7 if king.color == "white" else 0  # Определяем строку короля: 7 для белых (e1), 0 для чёрных (e8).
        if self.board[row][4] != king:  # Проверяем, находится ли король на своей начальной позиции (e1 или e8, столбец 4).
            return options  # Если король не на месте, возвращаем пустой словарь (рокировка невозможна).
        rook = self.board[row][7]  # Получаем фигуру на позиции h1/h8 (правая ладья для короткой рокировки).
        if rook and isinstance(rook, Rook) and not rook.has_moved:  # Проверяем, что это ладья, и она не ходила.
            if self.board[row][5] is None and self.board[row][6] is None:  # Проверяем, пусты ли клетки между королём и ладьёй (f и g).
                options["короткая"] = {"king_target": (row, 6), "rook_target": (row, 5)}  # Добавляем вариант короткой рокировки: король на g, ладья на f.
        rook = self.board[row][0]  # Получаем фигуру на позиции a1/a8 (левая ладья для длинной рокировки).
        if rook and isinstance(rook, Rook) and not rook.has_moved:  # Проверяем, что это ладья, и она не ходила.
            if self.board[row][1] is None and self.board[row][2] is None and self.board[row][3] is None:  # Проверяем, пусты ли клетки между королём и ладьёй (b, c, d).
                options["длинная"] = {"king_target": (row, 2), "rook_target": (row, 3)}  # Добавляем вариант длинной рокировки: король на c, ладья на d.
        return options  # Возвращаем словарь с возможными вариантами рокировки (может быть пустым).

    def perform_castling(self, king, side):  # Метод выполняет рокировку для указанного короля и стороны (короткая или длинная).
        castle_info = self.can_castle(king)  # Получаем словарь с информацией о возможных рокировках для короля.
        if side not in castle_info:  # Проверяем, возможна ли выбранная сторона рокировки.
            print("Рокировка невозможна.")  # Если выбранная сторона не доступна, выводим сообщение.
            return  # Выходим из метода, ничего не делая.
        info = castle_info[side]  # Получаем данные о рокировке для выбранной стороны (позиции короля и ладьи).
        row = 7 if king.color == "white" else 0  # Определяем строку короля: 7 для белых, 0 для чёрных.
        self.board[row][4] = None  # Убираем короля с его начальной позиции (e1 или e8).
        self.board[info["king_target"][0]][info["king_target"][1]] = king  # Перемещаем короля на целевую позицию (g1/g8 или c1/c8).
        king.has_moved = True  # Устанавливаем флаг, что король совершил ход (рокировка считается ходом).
        if side == "короткая":  # Если выполняется короткая рокировка.
            rook = self.board[row][7]  # Получаем ладью с позиции h1/h8.
            self.board[row][7] = None  # Убираем ладью с её начальной позиции.
        else:  # Если выполняется длинная рокировка.
            rook = self.board[row][0]  # Получаем ладью с позиции a1/a8.
            self.board[row][0] = None  # Убираем ладью с её начальной позиции.
        self.board[info["rook_target"][0]][info["rook_target"][1]] = rook  # Перемещаем ладью на целевую позицию (f1/f8 или d1/d8).
        rook.has_moved = True  # Устанавливаем флаг, что ладья совершила ход.
        print("Рокировка выполнена.")  # Выводим сообщение об успешном выполнении рокировки.
        self.turn = "black" if self.turn == "white" else "white"  # Переключаем ход на другого игрока (с белых на чёрных или наоборот).

    def check_status(self):  # Метод проверяет текущий статус игры (шах, мат).
        for i in range(8):  # Проходим по всем строкам доски.
            for j in range(8):  # Проходим по всем столбцам доски.
                piece = self.board[i][j]  # Получаем фигуру на текущей клетке.
                if piece and isinstance(piece, King):  # Если на клетке король.
                    if self.is_under_threat((i, j), piece):  # Проверяем, находится ли король под угрозой (шахом).
                        moves = piece.get_possible_moves((i, j), self.board)  # Получаем список возможных ходов короля.
                        if not moves:  # Если у короля нет возможных ходов.
                            print(f"Мат! Король {piece.color} потерпел поражение.")  # Выводим сообщение о мате (игра окончена).
                        else:  # Если у короля есть ходы.
                            print(f"Шах! Король {piece.color} под ударом.")  # Выводим сообщение о шахе.

    def move_piece(self, start, end):  # Метод перемещает фигуру с позиции start на позицию end.
        possible = self.get_possible_moves(start)  # Получаем список возможных ходов для фигуры на позиции start.
        if end in possible:  # Проверяем, является ли end допустимым ходом для фигуры.
            self.save_state()  # Сохраняем текущее состояние доски перед выполнением хода.
            piece = self.board[start[0]][start[1]]  # Получаем фигуру с начальной позиции.
            if isinstance(piece, Pawn) and self.en_passant_target is not None and end == self.en_passant_target:  # Проверяем, является ли ход взятием на проходе.
                captured_square = (start[0], end[1])  # Определяем позицию пешки противника, которую нужно убрать (та же строка, что у start, столбец из end).
                self.board[captured_square[0]][captured_square[1]] = None  # Убираем захваченную пешку с доски.
                print("Взятие на проходе выполнено!")  # Выводим сообщение о взятии на проходе.
            self.board[end[0]][end[1]] = piece  # Перемещаем фигуру на конечную позицию.
            self.board[start[0]][start[1]] = None  # Убираем фигуру с начальной позиции (она теперь пуста).
            if isinstance(piece, Pawn) and abs(start[0] - end[0]) == 2:  # Проверяем, был ли это двойной ход пешки.
                self.en_passant_target = ((start[0] + end[0]) // 2, end[1])  # Устанавливаем клетку для возможного взятия на проходе (середина между start и end).
                self.en_passant_pawn = end  # Запоминаем новую позицию пешки, которая сделала двойной ход.
            else:  # Если это не двойной ход пешки.
                self.en_passant_target = None  # Сбрасываем возможность взятия на проходе.
                self.en_passant_pawn = None  # Сбрасываем координаты пешки для взятия на проходе.
            if isinstance(piece, Pawn):  # Проверяем, является ли перемещённая фигура пешкой.
                if (piece.color == "white" and end[0] == 0) or (piece.color == "black" and end[0] == 7):  # Проверяем, достигла ли пешка последней строки (0 для белых, 7 для чёрных).
                    print("Пешка превращается в ферзя!")  # Выводим сообщение о промоции пешки.
                    piece = Queen(piece.color)  # Заменяем пешку на ферзя того же цвета.
                    self.board[end[0]][end[1]] = piece  # Обновляем доску, размещая нового ферзя на конечной позиции.
            piece.has_moved = True  # Устанавливаем флаг, что фигура совершила ход.
            self.turn = "black" if self.turn == "white" else "white"  # Переключаем ход на другого игрока.
            self.check_status()  # Проверяем статус игры после хода (шах или мат).
        else:  # Если конечная позиция не входит в список возможных ходов.
            print("Неверный ход")  # Выводим сообщение о недопустимом ходе.

    def play(self):  # Метод запускает игровой процесс для шахмат.
        while True:  # Запускаем бесконечный цикл для продолжения игры.
            self.display_board()  # Отображаем текущее состояние доски.
            move_input = input(f"{self.turn} ход. Введите ход (например, e2 e4) или команду 'назад n': ")  # Запрашиваем у пользователя ход или команду отмены.
            cmd = move_input.strip().lower()
            if cmd in ["0-0", "o-o", "короткая"]:
                king = self.board[7 if self.turn == "white" else 0][4]
                self.perform_castling(king, "короткая")
                continue
            if cmd in ["0-0-0", "o-o-o", "длинная"]:
                king = self.board[7 if self.turn == "white" else 0][4]
                self.perform_castling(king, "длинная")
                continue

            if move_input.startswith("назад"):  # Проверяем, начинается ли ввод с команды "назад".
                parts = move_input.split()  # Разделяем ввод на части по пробелам (например, ["назад", "2"]).
                if len(parts) == 2 and parts[1].isdigit():  # Проверяем, что команда состоит из двух частей и вторая часть — число.
                    n = int(parts[1])  # Преобразуем вторую часть в целое число (количество ходов для отката).
                    self.undo_moves(n)  # Выполняем откат на n ходов назад.
                else:  # Если команда "назад" введена некорректно.
                    print("Неверная команда 'назад'")  # Выводим сообщение об ошибке.
                continue  # Переходим к следующей итерации цикла (ждём новый ввод).
            try:  # Пробуем обработать ход пользователя.
                start_str, end_str = move_input.split()  # Разделяем ввод на начальную и конечную позиции (например, "e2 e4" → ["e2", "e4"]).
                start = self.convert_input_to_coords(start_str)  # Преобразуем начальную позицию в координаты (например, "e2" → (6, 4)).
                end = self.convert_input_to_coords(end_str)  # Преобразуем конечную позицию в координаты (например, "e4" → (4, 4)).
                self.move_piece(start, end)  # Выполняем ход, перемещая фигуру с позиции start на позицию end.
            except Exception as e:  # Если произошла ошибка при обработке ввода (например, неверный формат).
                print("Ошибка ввода хода:", e)  # Выводим сообщение об ошибке с указанием её причины.


# =============================== Классы шахматных фигур ===============================
class Piece:  # Базовый класс для всех шахматных фигур.
    def __init__(self, color):  # Конструктор класса Piece, принимает цвет фигуры.
        self.color = color  # Устанавливаем цвет фигуры ("white" или "black").
        self.has_moved = False  # Инициализируем флаг, показывающий, ходила ли фигура (по умолчанию False).

    @property
    def symbol(self):  # Свойство для получения символа фигуры (используется для отображения).
        return "?"  # По умолчанию возвращаем "?", если символ не переопределён в дочернем классе.

    def get_possible_moves(self, pos, board):  # Метод для получения списка возможных ходов фигуры (абстрактный).
        return []  # По умолчанию возвращаем пустой список (должен быть переопределён в дочерних классах).


class Pawn(Piece):  # Класс для пешки, наследуется от Piece.
    @property
    def symbol(self):  # Свойство для получения символа пешки.
        return "P" if self.color == "white" else "p"  # Возвращаем "P" для белой пешки, "p" для чёрной.

    def get_possible_moves(self, pos, board, en_passant_target=None):  # Метод возвращает возможные ходы для пешки.
        moves = []  # Создаём пустой список для хранения возможных ходов.
        i, j = pos  # Разделяем позицию на индексы строки (i) и столбца (j).
        direction = -1 if self.color == "white" else 1  # Определяем направление движения: -1 для белых (вверх), 1 для чёрных (вниз).
        if 0 <= i + direction < 8 and board[i + direction][j] is None:  # Проверяем, свободна ли клетка прямо впереди пешки.
            moves.append((i + direction, j))  # Добавляем ход на одну клетку вперёд в список возможных ходов.
            if not self.has_moved and 0 <= i + 2 * direction < 8 and board[i + 2 * direction][j] is None:  # Проверяем, может ли пешка сделать двойной ход (если она ещё не ходила).
                moves.append((i + 2 * direction, j))  # Добавляем ход на две клетки вперёд.
        for dj in [-1, 1]:  # Проверяем диагональные клетки для захвата (слева и справа).
            ni, nj = i + direction, j + dj  # Вычисляем координаты диагональной клетки.
            if 0 <= ni < 8 and 0 <= nj < 8:  # Проверяем, что диагональная клетка находится в пределах доски.
                if board[ni][nj] and board[ni][nj].color != self.color:  # Если на диагонали есть фигура противника.
                    moves.append((ni, nj))  # Добавляем ход для захвата этой фигуры.
        if en_passant_target is not None:  # Проверяем, есть ли возможность взятия на проходе.
            for dj in [-1, 1]:  # Проверяем диагонали слева и справа.
                if (i + direction, j + dj) == en_passant_target:  # Если диагональная клетка совпадает с целью взятия на проходе.
                    moves.append(en_passant_target)  # Добавляем ход для взятия на проходе.
        return moves  # Возвращаем список всех возможных ходов пешки.


class Rook(Piece):  # Класс для ладьи, наследуется от Piece.
    @property
    def symbol(self):  # Свойство для получения символа ладьи.
        return "R" if self.color == "white" else "r"  # Возвращаем "R" для белой ладьи, "r" для чёрной.

    def get_possible_moves(self, pos, board):  # Метод возвращает возможные ходы для ладьи.
        moves = []  # Создаём пустой список для хранения возможных ходов.
        i, j = pos  # Разделяем позицию на индексы строки (i) и столбца (j).
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # Определяем направления движения ладьи: вниз, вверх, вправо, влево.
        for di, dj in directions:  # Проходим по каждому направлению.
            rr, cc = i + di, j + dj  # Начинаем с первой клетки в текущем направлении.
            while 0 <= rr < 8 and 0 <= cc < 8:  # Продолжаем движение, пока клетка находится в пределах доски.
                if board[rr][cc] is None:  # Если клетка пуста.
                    moves.append((rr, cc))  # Добавляем её в список возможных ходов.
                else:  # Если на клетке есть фигура.
                    if board[rr][cc].color != self.color:  # Если это фигура противника.
                        moves.append((rr, cc))  # Добавляем ход для захвата.
                    break  # Прерываем цикл, так как дальше идти нельзя (фигура блокирует путь).
                rr += di  # Переходим к следующей клетке в текущем направлении.
                cc += dj  # Переходим к следующей клетке в текущем направлении.
        return moves  # Возвращаем список всех возможных ходов ладьи.


class Knight(Piece):  # Класс для коня, наследуется от Piece.
    @property
    def symbol(self):  # Свойство для получения символа коня.
        return "N" if self.color == "white" else "n"  # Возвращаем "N" для белого коня, "n" для чёрного.

    def get_possible_moves(self, pos, board):  # Метод возвращает возможные ходы для коня.
        moves = []  # Создаём пустой список для хранения возможных ходов.
        i, j = pos  # Разделяем позицию на индексы строки (i) и столбца (j).
        offsets = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]  # Определяем все возможные смещения коня (Г-образные ходы).
        for dr, dc in offsets:  # Проходим по каждому возможному смещению.
            rr, cc = i + dr, j + dc  # Вычисляем координаты целевой клетки.
            if 0 <= rr < 8 and 0 <= cc < 8:  # Проверяем, что клетка находится в пределах доски.
                if board[rr][cc] is None or board[rr][cc].color != self.color:  # Если клетка пуста или на ней фигура противника.
                    moves.append((rr, cc))  # Добавляем ход в список.
        return moves  # Возвращаем список всех возможных ходов коня.


class Bishop(Piece):  # Класс для слона, наследуется от Piece.
    @property
    def symbol(self):  # Свойство для получения символа слона.
        return "B" if self.color == "white" else "b"  # Возвращаем "B" для белого слона, "b" для чёрного.

    def get_possible_moves(self, pos, board):  # Метод возвращает возможные ходы для слона.
        moves = []  # Создаём пустой список для хранения возможных ходов.
        i, j = pos  # Разделяем позицию на индексы строки (i) и столбца (j).
        directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]  # Определяем направления движения слона: диагонали (вниз-вправо, вниз-влево, вверх-вправо, вверх-влево).
        for di, dj in directions:  # Проходим по каждому направлению.
            rr, cc = i + di, j + dj  # Начинаем с первой клетки в текущем направлении.
            while 0 <= rr < 8 and 0 <= cc < 8:  # Продолжаем движение, пока клетка находится в пределах доски.
                if board[rr][cc] is None:  # Если клетка пуста.
                    moves.append((rr, cc))  # Добавляем её в список возможных ходов.
                else:  # Если на клетке есть фигура.
                    if board[rr][cc].color != self.color:  # Если это фигура противника.
                        moves.append((rr, cc))  # Добавляем ход для захвата.
                    break  # Прерываем цикл, так как дальше идти нельзя.
                rr += di  # Переходим к следующей клетке в текущем направлении.
                cc += dj  # Переходим к следующей клетке в текущем направлении.
        return moves  # Возвращаем список всех возможных ходов слона.


class Queen(Piece):  # Класс для ферзя, наследуется от Piece.
    @property
    def symbol(self):  # Свойство для получения символа ферзя.
        return "Q" if self.color == "white" else "q"  # Возвращаем "Q" для белого ферзя, "q" для чёрного.

    def get_possible_moves(self, pos, board):  # Метод возвращает возможные ходы для ферзя.
        return Rook.get_possible_moves(self, pos, board) + Bishop.get_possible_moves(self, pos, board)  # Ферзь объединяет ходы ладьи и слона: вызываем их методы и складываем списки.


class King(Piece):  # Класс для короля, наследуется от Piece.
    @property
    def symbol(self):  # Свойство для получения символа короля.
        return "K" if self.color == "white" else "k"  # Возвращаем "K" для белого короля, "k" для чёрного.

    def get_possible_moves(self, pos, board):  # Метод возвращает возможные ходы для короля.
        moves = []  # Создаём пустой список для хранения возможных ходов.
        i, j = pos  # Разделяем позицию на индексы строки (i) и столбца (j).
        for dr in [-1, 0, 1]:  # Проходим по всем возможным изменениям строки (-1, 0, 1).
            for dc in [-1, 0, 1]:  # Проходим по всем возможным изменениям столбца (-1, 0, 1).
                if dr == 0 and dc == 0:  # Пропускаем случай, когда король остаётся на месте (нулевое смещение).
                    continue  # Переходим к следующей итерации вложенного цикла.
                rr, cc = i + dr, j + dc  # Вычисляем координаты целевой клетки.
                if 0 <= rr < 8 and 0 <= cc < 8:  # Проверяем, что клетка находится в пределах доски.
                    if board[rr][cc] is None or board[rr][cc].color != self.color:  # Если клетка пуста или на ней фигура противника.
                        moves.append((rr, cc))  # Добавляем ход в список.
        return moves  # Возвращаем список всех возможных ходов короля.


# =============================== ШАШКИ ===============================
class Checker(Piece):  # Класс для шашки, наследуется от Piece.
    def __init__(self, color):  # Конструктор класса Checker, принимает цвет шашки.
        super().__init__(color)  # Вызываем конструктор родительского класса Piece для установки цвета и has_moved.
        self.king = False  # Инициализируем флаг, показывающий, является ли шашка дамкой (по умолчанию False).

    @property
    def symbol(self):  # Свойство для получения символа шашки.
        if self.king:  # Если шашка является дамкой.
            return "WK" if self.color == "white" else "BK"  # Возвращаем "WK" для белой дамки, "BK" для чёрной.
        else:  # Если шашка обычная.
            return "W" if self.color == "white" else "B"  # Возвращаем "W" для белой шашки, "B" для чёрной.

    def get_possible_moves(self, pos, board):  # Метод возвращает возможные ходы для шашки.
        moves = []  # Создаём пустой список для хранения возможных ходов.
        i, j = pos  # Разделяем позицию на индексы строки (i) и столбца (j).
        direction = -1 if self.color == "white" else 1  # Определяем направление движения: -1 для белых (вверх), 1 для чёрных (вниз).
        if self.king:  # Если шашка — дамка.
            directions = [(-1, -1), (-1, 1), (1, -1), (1, 1)]  # Дамка может двигаться по всем четырём диагоналям.
        else:  # Если шашка обычная.
            directions = [(direction, -1), (direction, 1)]  # Обычная шашка движется только вперёд по двум диагоналям.
        for dr, dc in directions:  # Проходим по каждому направлению.
            ni, nj = i + dr, j + dc  # Вычисляем координаты соседней клетки.
            if 0 <= ni < 8 and 0 <= nj < 8 and board[ni][nj] is None:  # Если соседняя клетка в пределах доски и пуста.
                moves.append((ni, nj))  # Добавляем простой ход на соседнюю клетку.
            jump_r, jump_c = i + 2 * dr, j + 2 * dc  # Вычисляем координаты клетки для прыжка через фигуру (захват).
            if (0 <= ni < 8 and 0 <= nj < 8 and 0 <= jump_r < 8 and 0 <= jump_c < 8):  # Проверяем, что обе клетки (соседняя и за ней) в пределах доски.
                enemy = board[ni][nj]  # Получаем фигуру на соседней клетке.
                if enemy and enemy.color != self.color and board[jump_r][jump_c] is None:  # Если на соседней клетке враг, а клетка за ней пуста.
                    moves.append((jump_r, jump_c))  # Добавляем ход для захвата (прыжок через врага).
        return moves  # Возвращаем список всех возможных ходов шашки.


class CheckersGame(Game):  # Класс для игры в шашки, наследуется от Game.
    def __init__(self):  # Конструктор класса CheckersGame.
        super().__init__()  # Вызываем конструктор родительского класса Game для инициализации move_history.
        self.board = self.init_board()  # Инициализируем доску для шашек начальными позициями.
        self.turn = "white"  # Устанавливаем, что первый ход за белыми.

    def init_board(self):  # Метод для создания и инициализации доски для шашек.
        board = [[None for _ in range(8)] for _ in range(8)]  # Создаём двумерный список 8x8, заполненный значениями None (пустая доска).
        for i in range(3):  # Проходим по первым трём строкам (0, 1, 2) для чёрных шашек.
            for j in range(8):  # Проходим по всем столбцам в строке.
                if (i + j) % 2 == 1:  # Размещаем шашки только на тёмных клетках (сумма индексов нечётная).
                    board[i][j] = Checker("black")  # Устанавливаем чёрную шашку на соответствующей клетке.
        for i in range(5, 8):  # Проходим по последним трём строкам (5, 6, 7) для белых шашек.
            for j in range(8):  # Проходим по всем столбцам в строке.
                if (i + j) % 2 == 1:  # Размещаем шашки только на тёмных клетках.
                    board[i][j] = Checker("white")  # Устанавливаем белую шашку на соответствующей клетке.
        return board  # Возвращаем полностью инициализированную доску для шашек.

    def is_under_threat(self, pos, piece):  # Метод проверяет, находится ли шашка на позиции pos под угрозой (может быть захвачена).
        enemy_color = "black" if piece.color == "white" else "white"  # Определяем цвет противника.
        for i in range(8):  # Проходим по всем строкам доски.
            for j in range(8):  # Проходим по всем столбцам доски.
                enemy = self.board[i][j]  # Получаем фигуру на текущей клетке.
                if enemy and enemy.color == enemy_color:  # Если на клетке есть фигура противника.
                    if enemy.king:  # Если противник — дамка.
                        directions = [(-1, -1), (-1, 1), (1, -1), (1, 1)]  # Дамка может атаковать по всем четырём диагоналям.
                    else:  # Если противник — обычная шашка.
                        direction = -1 if enemy.color == "white" else 1  # Определяем направление атаки: вверх для белых, вниз для чёрных.
                        directions = [(direction, -1), (direction, 1)]  # Обычная шашка атакует вперёд по двум диагоналям.
                    for dr, dc in directions:  # Проходим по каждому направлению атаки.
                        mid_r, mid_c = i + dr, j + dc  # Вычисляем координаты средней клетки (где находится атакуемая шашка).
                        landing_r, landing_c = i + 2 * dr, j + 2 * dc  # Вычисляем координаты клетки, на которую прыгнет атакующая шашка.
                        if (0 <= mid_r < 8 and 0 <= mid_c < 8 and 0 <= landing_r < 8 and 0 <= landing_c < 8):  # Проверяем, что обе клетки в пределах доски.
                            if (mid_r, mid_c) == pos and self.board[landing_r][landing_c] is None:  # Если средняя клетка — это pos и целевая клетка пуста.
                                return True  # Возвращаем True, шашка под угрозой захвата.
        return False  # Если ни одна шашка противника не угрожает, возвращаем False.

    def display_board(self):  # Метод для отображения текущего состояния доски для шашек.
        print("  A B C D E F G H")  # Выводим заголовок с обозначениями столбцов (A-H).
        print()  # Печатаем пустую строку для разделения.
        for i in range(8):  # Проходим по всем строкам доски.
            row_label = 8 - i  # Вычисляем номер строки (от 8 до 1 сверху вниз).
            row_str = str(row_label)  # Начинаем строку с номера строки.
            for j in range(8):  # Проходим по всем столбцам в строке.
                piece = self.board[i][j]  # Получаем шашку на текущей клетке.
                if piece:  # Если на клетке есть шашка.
                    cell = piece.symbol  # Получаем символ шашки (например, "W" или "BK").
                    if self.is_under_threat((i, j), piece):  # Проверяем, находится ли шашка под угрозой.
                        cell += "!"  # Если да, добавляем "!" к символу (например, "W!").
                else:  # Если клетка пуста.
                    cell = "."  # Используем точку для обозначения пустой клетки.
                row_str += " " + cell  # Добавляем символ клетки к строке с пробелом перед ним.
            row_str += " " + str(row_label)  # Добавляем номер строки в конец строки.
            print(row_str)  # Выводим сформированную строку с содержимым ряда.
        print()  # Печатаем пустую строку после доски.
        print("  A B C D E F G H")  # Повторно выводим заголовок с обозначениями столбцов.

    def convert_input_to_coords(self, inp):  # Метод преобразует ввод пользователя (например, "c3") в координаты (row, col).
        col = ord(inp[0].lower()) - ord('a')  # Преобразуем букву (A-H) в индекс столбца (0-7).
        row = 8 - int(inp[1])  # Преобразуем цифру (1-8) в индекс строки (0-7).
        return (row, col)  # Возвращаем кортеж с координатами (строка, столбец).

    def get_possible_moves(self, pos):  # Метод возвращает список возможных ходов для шашки на позиции pos.
        piece = self.board[pos[0]][pos[1]]  # Получаем шашку на указанной позиции.
        if piece:  # Если на позиции есть шашка.
            return piece.get_possible_moves(pos, self.board)  # Вызываем метод get_possible_moves для этой шашки.
        return []  # Если на позиции нет шашки, возвращаем пустой список.

    def move_piece(self, start, end):  # Метод перемещает шашку с позиции start на позицию end.
        possible = self.get_possible_moves(start)  # Получаем список возможных ходов для шашки на позиции start.
        if end in possible:  # Проверяем, является ли end допустимым ходом.
            self.save_state()  # Сохраняем текущее состояние доски перед ходом.
            piece = self.board[start[0]][start[1]]  # Получаем шашку с начальной позиции.
            if abs(end[0] - start[0]) == 2:  # Проверяем, является ли ход прыжком (захватом) — разница в строках равна 2.
                mid_r = (start[0] + end[0]) // 2  # Вычисляем строку захваченной шашки (середина между start и end).
                mid_c = (start[1] + end[1]) // 2  # Вычисляем столбец захваченной шашки.
                self.board[mid_r][mid_c] = None  # Убираем захваченную шашку с доски.
            self.board[end[0]][end[1]] = piece  # Перемещаем шашку на конечную позицию.
            self.board[start[0]][start[1]] = None  # Убираем шашку с начальной позиции.
            if piece.color == "white" and end[0] == 0 and not piece.king:  # Проверяем, достигла ли белая шашка последней строки (0) и не является ли она уже дамкой.
                piece.king = True  # Превращаем шашку в дамку.
                print("Белая шашка стала дамкой!")  # Выводим сообщение о превращении.
            elif piece.color == "black" and end[0] == 7 and not piece.king:  # Проверяем, достигла ли чёрная шашка последней строки (7) и не является ли она уже дамкой.
                piece.king = True  # Превращаем шашку в дамку.
                print("Чёрная шашка стала дамкой!")  # Выводим сообщение о превращении.
            while True:  # Запускаем цикл для проверки дополнительных захватов.
                new_moves = piece.get_possible_moves(end, self.board)  # Получаем новые возможные ходы после перемещения.
                captures = [m for m in new_moves if abs(m[0] - end[0]) == 2]  # Фильтруем ходы, которые являются захватами (прыжки через шашку).
                if captures:  # Если есть возможные захваты.
                    print("Дополнительное взятие возможно:", captures)  # Выводим список доступных захватов.
                    nxt = input("Введите следующий ход (например, 'C3') или 'skip': ")  # Запрашиваем у пользователя следующий ход или команду пропуска.
                    if nxt.strip().lower() == "skip":  # Если пользователь ввёл "skip" (игнорируем регистр и пробелы).
                        break  # Выходим из цикла дополнительных захватов.
                    try:  # Пробуем обработать ввод пользователя.
                        nxt_coords = self.convert_input_to_coords(nxt)  # Преобразуем введённый ход в координаты.
                        if nxt_coords in captures:  # Проверяем, является ли введённый ход одним из доступных захватов.
                            self.move_piece(end, nxt_coords)  # Рекурсивно выполняем следующий захват.
                            end = nxt_coords  # Обновляем текущую позицию шашки.
                            piece = self.board[end[0]][end[1]]  # Обновляем ссылку на шашку после перемещения.
                        else:  # Если введённый ход не является захватом.
                            print("Неверный ход для побития.")  # Выводим сообщение об ошибке.
                            break  # Выходим из цикла.
                    except Exception as e:  # Если произошла ошибка при обработке ввода.
                        print("Ошибка:", e)  # Выводим сообщение об ошибке.
                        break  # Выходим из цикла.
                else:  # Если нет дополнительных захватов.
                    break  # Выходим из цикла.
            self.turn = "black" if self.turn == "white" else "white"  # Переключаем ход на другого игрока.
        else:  # Если конечная позиция не входит в список возможных ходов.
            print("Неверный ход")  # Выводим сообщение о недопустимом ходе.

    def play(self):  # Метод запускает игровой процесс для шашек.
        while True:  # Запускаем бесконечный цикл для продолжения игры.
            self.display_board()  # Отображаем текущее состояние доски.
            cmd = input(f"{self.turn} ход. Введите 'a3 b4' или команду 'назад n': ")  # Запрашиваем у пользователя ход или команду отмены (например, "C3 E5").
            if cmd.startswith("назад"):  # Проверяем, начинается ли ввод с команды "назад".
                parts = cmd.split()  # Разделяем ввод на части (например, ["назад", "1"]).
                if len(parts) == 2 and parts[1].isdigit():  # Проверяем, что команда состоит из двух частей и вторая часть — число.
                    n = int(parts[1])  # Преобразуем вторую часть в целое число.
                    self.undo_moves(n)  # Выполняем откат на n ходов назад.
                else:  # Если команда "назад" введена некорректно.
                    print("Неверная команда 'назад'")  # Выводим сообщение об ошибке.
                continue  # Переходим к следующей итерации цикла.
            try:  # Пробуем обработать ход пользователя.
                start_str, end_str = cmd.split()  # Разделяем ввод на начальную и конечную позиции (например, "C3 E5").
                start = self.convert_input_to_coords(start_str)  # Преобразуем начальную позицию в координаты.
                end = self.convert_input_to_coords(end_str)  # Преобразуем конечную позицию в координаты.
                self.move_piece(start, end)  # Выполняем ход шашки с позиции start на позицию end.
            except Exception as e:  # Если произошла ошибка при обработке ввода.
                print("Ошибка ввода хода:", e)  # Выводим сообщение об ошибке с указанием причины.


# =============================== Запуск ===============================
def main():  # Основная функция для запуска программы.
    choice = input("Во что вы хотите сыграть? (шахматы/шашки): ").strip().lower()  # Запрашиваем у пользователя выбор игры, убираем пробелы и приводим к нижнему регистру.
    if choice.startswith("шах"):  # Проверяем, начинается ли выбор с "шах" (например, "шахматы").
        game = ChessGame()  # Создаём экземпляр класса ChessGame для игры в шахматы.
    elif choice.startswith("шаш"):  # Проверяем, начинается ли выбор с "шаш" (например, "шашки").
        game = CheckersGame()  # Создаём экземпляр класса CheckersGame для игры в шашки.
    else:  # Если выбор не соответствует ни шахматам, ни шашкам.
        print("Неверный выбор игры")  # Выводим сообщение об ошибке.
        return  # Завершаем функцию, ничего не запуская.
    game.play()  # Запускаем метод play для выбранной игры (шахматы или шашки).


if __name__ == "__main__":  # Проверяем, запущен ли скрипт напрямую (не импортирован как модуль).
    main()  # Вызываем основную функцию для старта программы.